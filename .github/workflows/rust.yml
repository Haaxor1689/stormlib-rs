name: Rust CI

on:
  push:
    branches: [master]
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always

jobs:
  codegen:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]
        include:
          # Define LIBCLANG_PATH for Windows directly within the matrix
          - os: windows-latest
            LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"
          # No specific LIBCLANG_PATH needed for macOS/Ubuntu typically

    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true
          token: ${{ secrets.GITHUB_TOKEN }}

      # Install LLVM/Clang based on OS
      - name: Install LLVM (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y clang libclang-dev

      - name: Install LLVM (Windows)
        if: runner.os == 'Windows'
        uses: egor-tensin/setup-clang@v1
        with:
          version: latest

      - name: Regenerate Bindings
        id: generate_bindings
        shell: bash
        run: |
          echo "Starting binding regeneration for ${{ runner.os }}..."

          # Build and run the bindgen tool for the native OS
          cargo build -p stormlib-bindgen --release
          cargo run -p stormlib-bindgen --release # This will generate bindings_OS.rs based on runner.os's cfg!

          # Determine the expected filename for this OS runner
          generated_file="crates/stormlib-sys/src/bindings_${{ runner.os == 'Windows' && 'windows' || runner.os == 'Linux' && 'linux' || 'macos' }}.rs"

          # Add *only this job's* generated file to the staging area
          git add "$generated_file"

          # Check if there are any staged changes (bash syntax)
          if ! git diff-index --quiet --cached HEAD; then
            echo "Detected changes in generated bindings for ${{ runner.os }}."
            echo "bindings_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "No changes detected in generated bindings for ${{ runner.os }}."
          fi
          echo "bindings_changed status: ${{ steps.generate_bindings.outputs.bindings_changed }}"
        working-directory: ${{ github.workspace }}

      - name: Commit and Push Changes (with retry for merge conflicts)
        shell: bash # Keep bash shell explicitly for the script
        if: |
          steps.generate_bindings.outputs.bindings_changed == 'true' &&
          github.event_name == 'push' &&
          github.ref == 'refs/heads/master'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          MAX_RETRIES=5
          RETRY_DELAY_SECONDS=5

          # generated_file variable is needed here for logic, but not directly in stash
          generated_file="crates/stormlib-sys/src/bindings_${{ runner.os == 'Windows' && 'windows' || runner.os == 'Linux' && 'linux' || runner.os == 'macos' }}.rs"

          # Temporarily stash *only* the staged changes.
          # This is the most reliable way to stash only what's in the index,
          # and it implicitly gets a message from the staged commit message if there was one.
          echo "Stashing *staged* changes before git pull --rebase..."
          git stash --staged || true # Use || true to prevent immediate failure if nothing to stash

          # Check if a stash was actually created. 'git stash list' gives an empty output if no stash.
          # If nothing was stashed, it implies no actual changes were to be committed.
          STASH_COUNT=$(git stash list | wc -l)
          if [[ "$STASH_COUNT" -eq 0 ]]; then
            echo "No staged changes found to stash. This implies the file was already up-to-date or not generated. Skipping commit/push."
            exit 0
          fi

          # Loop for pull, commit, push
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i to commit and push bindings for ${{ runner.os }}..."
            
            # Fetch latest changes before trying to pull --rebase
            git fetch origin master || {
              echo "Git fetch failed. Retrying in $RETRY_DELAY_SECONDS seconds..."
              sleep $RETRY_DELAY_SECONDS
              continue
            }

            # Rebase onto the latest master. Staged changes are now cleanly stashed.
            git rebase origin/master || {
              echo "Git rebase failed. Retrying in $RETRY_DELAY_SECONDS seconds..."
              # Reapply stash before next retry, in case rebase corrupted it.
              # And then drop it before the next fetch/rebase.
              git stash pop || true # pop here, if it exists
              sleep $RETRY_DELAY_SECONDS
              continue
            }
            
            # Reapply the stashed changes.
            echo "Applying stashed changes..."
            git stash pop --index || {
              echo "Git stash pop failed (possible conflict or no stash remaining). This should not happen if stash was successful and rebase was clean."
              exit 1 # Fail fast if we can't reapply our changes
            }
            
            # Check if there are still changes to commit after rebase and reapplying stash
            # This is vital because git stash pop could reintroduce the same file
            # as already committed by another job, leading to no actual changes.
            if git diff-index --quiet --cached HEAD; then
                echo "No changes to commit after rebase and reapplying stash. Skipping push."
                exit 0 # Exit successfully if no changes needed anymore
            fi

            git commit -m "chore(bindings): Auto-regenerate bindings for ${{ runner.os }}" && \
            git push origin master && \
            echo "Changes committed and pushed successfully for ${{ runner.os }}." && \
            exit 0 || {
              echo "Git push failed for ${{ runner.os }}. Retrying in $RETRY_DELAY_SECONDS seconds..."
              sleep $RETRY_DELAY_SECONDS
              # If push fails, the stash has been popped, so no need to pop again next loop.
            }
          done

          echo "Failed to commit and push bindings for ${{ runner.os }} after $MAX_RETRIES attempts."
          exit 1
        working-directory: ${{ github.workspace }}

  test_on_demand:
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]
        include:
          - os: macos-latest
          - os: ubuntu-latest
          - os: windows-latest
            LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"

    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Install LLVM (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y clang libclang-dev

      - name: Install LLVM (Windows)
        if: runner.os == 'Windows'
        uses: egor-tensin/setup-clang@v1
        with:
          version: latest

      - name: Run tests
        run: cargo test --all
        working-directory: ${{ github.workspace }}
